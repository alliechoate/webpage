---
title: "Helpful R Cheat Sheet"
author: "Allie Choate"
date: "06/01/2019"
slug: r-code
categories: []
tags: []
description: ~
---

```{r setup, include=F, echo=TRUE, tidy=T}
knitr::opts_chunk$set(dpi = 96)
```


# The Basics


## Reading In & Outputting Data:

**Read in a delimited text file**
```{r, eval=FALSE}
df <- read.table(‘file.txt’) 
#if you have missing codes, can do:
df <- read.table(‘file.txt’, missing = -99)
#if you have multiple missing codes, can do:
df <- read.table(‘file.txt’, na.strings=c("-98","-99", "-999")) 
````

**Similarly, read in a csv file**
```{r, eval=FALSE}
df <- read.csv(‘file.csv’)
```

<br>

**Read out a delimited text file**
```{r, eval=FALSE}
write.table(df, ‘file.txt’) #saves this to your working directory 
```

**Read out a csv  file**
```{r, eval=FALSE}
write.csv(df, ‘file.csv’)
```
<br>
<br>

#### Write an R-based datset to a SPSS file using 'foreign'
```{r, eval=FALSE}
library(foreign)
write.foreign(data.frame, "mydata.txt", 
              "mydata1.sps", #name you want your SPSS file to be called
              package="SPSS")
```


<br>
<br>
<br>


## Checking Data Structure 


### Checking Structure/Dimensions of a DF 

**Check structure/dimension of a variable of df**
```{r, eval=FALSE}
str(dat) #check structure of data
dim(dat) #check the number of dimensions of data
class(dat$vbl) #check what type of class a vbl is
```

**Print First or Last 10 Rows of the Data**
```{r, eval=FALSE}
head(mydata, n=10) #first
tail(mydata, n=10) #last
```
<br>
<br>


### Quick Sorting of Data 
```{r, eval=FALSE}
#Sort dataset by ID
df[order(df$ID),]

#Sort dataset by Item1 and Item2 
df[order(df$Item1,df$Item2),]

#Sort dataset by Item1 (ascending) and Item2 (descending)
df[order(df$Item1, -df$Item2),]
```
<br>
<br>


## Other Helpful Data Commands


### Re-naming Variables in a df
**View Names in df**
```{r, eval=FALSE}
names(df) 
#or
dput(names(df))
```
**Re-name all names in dataset, generally speaking**
```{r, eval=FALSE}
names(df)<- c("whatever1", "whatever2","whatever3")
```

**Re-name only Row Names:**
```{r, eval=FALSE}
# For Row Names
rownames(df)<- c("v1","v2","v3")
#or more simply
rownames(df)<- paste0("V", 1:3)
```

**Re-Name only Columns**
```{r, eval=FALSE}
colnames(df)<- c("var1","var2","var3")
```
<br>
<br>


#### Changing The Class of Variables in R

**Setting a Variable as Ordinal/Numeric/Categorical**
```{r, eval=FALSE}
as.ordered(df$x) #x = some variable 
as.numeric(df$x)
as.factor(df$x)
```

**Change the level names of a categorical variable**
```{r, eval=FALSE}
data$vbl.name<- factor(data$vbl.name, levels = c(0,1), labels = c("Male","Female"))
```

**Change ALL variables to be all numeric:**
```{r, eval=FALSE}
new.df <- data.frame(lapply(old.df, function(x) as.numeric(as.character(x))))
```

<br>
<br>


***


<br>
<br>

# Missing Data Checks


### View & Delete Missingness - (this does listwise deletion)**
```{r, eval=FALSE}
sum(is.na(df)) #easy way to see how many 'NAs' are in dataset
sum(is.na(df$x)) #or similarly, check for a particular variable

# Omit any missing data entries
clean.df<-na.omit(df)
```

**Function to change missing values to 'NA' (useful for if you forgot to tell R what your missing values were when you read in your data)**
```{r, eval=FALSE}
fix_missing <- function(x) {
  x[x == -99] <- NA
  x
}
df[] <- lapply(df, fix_missing)
```

<br>
<br>

### Using the mice package for Missing Data Checks:
```{r, eval=FALSE}
library(mice) #load the mice package 

## look at the percent of missingness in data:
pm <- colMeans(is.na(missData))
pm

## Compute the covaraince coverage using the md.pairs() is part of the mice package
cover <- md.pairs(missData)$rr / nrow(missData)
cover
#visuals 
hist(cover)
range(cover)


## Compute the unique response patterns:
unique.rep <- md.pattern(missData)
unique.rep
```
<br>
<br>


***

<br>
<br>


# Basic Descriptives

<br>

### Base R - Descriptive/Frequency Commands
```{r, eval=FALSE}
# x = some variable

sd(df$x)                  # Calculate standard deviation
summary(df$x)            # Returns a summary of x: mean, min, max etc.
t.test(df$x)              # Student's t-test
var(df$x)                 # Calculate variance
density(df$x)            # Compute kernel density estimates
table(df$Gender)        # counts for gender categories
table(df$`Marital Status`, data$Gender) # cross classication counts for 'gender' by 'marital status'

```

### Other Descriptive Option (using Rmisc)
```{r, eval=FALSE}
library(Rmisc)
Descriptives<-summarySE(df, measurevar="vblofinterest", groupvars=c("gender","age"))
```

### Descriptives Option #2 (using Psych)
```{r, eval=FALSE}
library(psych)
describeBy(df$vbl, group = df$groupvar)
describe(df$vbl) # no group
```

<br>
<br>

***

<br>
<br>



# Subsetting Data in R:

### Typical Ways to Subset Data:

1.) my_df[1:3] (no comma) will subset my_df, returning the first three columns as a data frame.

2.) my_df[1:3, ] (with comma, numbers to left of the comma) will subset my_df and return the first three rows as a data frame.

3.) my_df[, 1:3] (with comma, numbers to right of the comma) will subset my_df and return the first three columns as a data frame, the same as my_df[1:3].

<br>

### Easy Example to Physically See How Subsetting Works in R:

**For subsetting rows:**
```{r, eval=TRUE, echo=TRUE, collapse=TRUE}
# creating a fake df
df <- data.frame(x = 1:4, y = 4:1, z = letters[1:4]) 

# Subsetting by row '3'
df[df$x == 3, ]

# Calling Row 1 & 3
df[c(1, 3), ]
```
**For subsetting columns:**
```{r, eval=TRUE, echo=TRUE, collapse=TRUE}
# There are two ways to select columns from a data frame: 

  # 1. Like a list
new.df <- df[c("x", "z")] #based on vbl names
new.df <- df[c(1:3)] # based on vbl columns numbers, bracket indicates we're subsetting column 1 through 3.
  
  # 2. Like a matrix
new.df <-df[, c("x", "z")]
new.df <-df[, c(1:3)]


# There's an important difference if you select a SINGLE column...
# ...matrix subsetting simplifies by default, list subsetting does not.

str(df["x"])
#  VS
str(df[, "x"])
```

**Quick Subsetting of Rows & Columns Together:**
```{r, eval=TRUE, echo=TRUE}
# create random distribution. For example, draw 5 random samples of size 10 from a N(10,1):
fake.dat<-matrix(rnorm(n=100,mean=10,sd=1),ncol=10, nrow=20)
#subset 1-8 rows and columns 1:2
new.df<-fake.dat[1:6, 1:4]
print(new.df)
```
* Can see that we successfully selected rows 1-6 and columns 1-4. 

* If you wanted to select columns or rows that were not right next to each other, can do this:
```{r, eval=TRUE, echo=TRUE}
fake.dat[c(1,4,9), c(1,7,8)] #this selects rows 1,4, & 9 and columns 1, 7, & 8.
```

<br>
<br>

#### Delete a Column From a df

**3 ways to delete a column quickly:**
```{r, eval=FALSE}
new.data<- df[colnames(df)!="vblname.to.exclude"]

# Can also do this:
df$vbl.to.exclude<- NULL

#OR if you know column(s) you want to remove, can do this:
new.data<- df[-c(2:4)] #this removes columns 2:4
```
<br>
<br>

### Subsetting Based on Specific Components of the df:

** Subsetting based on a level of a factor - will subset all of the data and include only that specific 'level' of a categorical variable.**
```{r, eval=FALSE}
new.data<- subset(df, level===1) #level = whatever the level of your factor is called that you're interested in.
```                                                        

**Subsetting based on specific values of a variable**
```{r, eval=FALSE}
#Select cases only where Vbl1>= 20 and Vbl2 >10 + select a few other variables for a new dataset.
newdata <- subset(df, df$Vbl1>= 20 & df$Vbl2 >10, 
                  select=c(Vbl1, Vbl2, gender, ID)) # These are all the other variables you want to include in the new df
```

**Another example for subsetting based on specific values of a variable**
```{r, eval=FALSE}
#Select only cases where gender is 0 (male), and 'depression' is greater then 10. Also select all variables from 'Anxiety' to 'PTSD'
newdata2 <- subset(df, df$gender=="0" & df$depression>10, select=c(Anxiety:PTSD))
```

**Subsetting THIS condition OR that condition**
```{r, eval=FALSE}
#If we wanted all rows where either d == "A" or a > 0.5, use the OR operator (|):
my_df[which(my_df$d == "A" | my_df$a > 0.5),]
```

<br>
<br>


### Alternative Methods for Quick Subsetting - Use 'dplyr' 

**dplyr is nice if you want to subset from your original dataset based on a set of variables that are similarly named. For example: **
```{r, eval=FALSE}
library(dplyr)
# Variable starts with...
df_pract<-select(data, starts_with("var")) #example would be "var1","var2","var3", etc.
# Variable ends with...
df_pract<-select(data, ends_with("14"))
```

<br>
<br>

***

<br>
<br>


# Recoding & Re-Scaling Variables:

#### Quick Way to Manually Re-Code ALL Variables in a df

**To demonstrate, making fake data**

  * 'Survey' function for 'var1' -->draws 20 samples from integers 1:5 w/ replacement
```{r, eval=TRUE, echo=T}
library(car)
survey <- data.frame("var1" = sample(x = 1:5, size = 20, replace = TRUE),
                     "var2" = rep(1:5, each=4),
                     "age" =  sample(x = 10:45, size = 20, replace = TRUE))
```

**Now, let's just change var1 to have different values (currently has values 1-5)**

  * Brackets allow subsetting of columns...could also do 'survey$var1'
  * This will change all '5' in column 1 (var1) to be 6, and all '1s' to be '1.5.'
```{r, eval=TRUE, echo=T}
survey$var1<- lapply(survey[[1]], function(x) {x<- recode(x, "5=6;1=1.5"); x})
```

**If we wanted to rescale all values in all columns of the entire survey dataset, we could do so like this:**
```{r, eval=TRUE, echo=T}
recode.cols<- apply(survey, 2, function(x) {x<- recode(x, "5=6;1=1.5"); x})
head(recode.cols)

# to re-scale all row values, just change the '2' to a '1'
recode.rows<- apply(survey, 1, function(x) {x<- recode(x, "5=6;1=1.5"); x})
head(recode.rows)
```


#### Rescaling a Variable to be between 0-1 with the scales package:

  * Use same 'survey' dataset from above:
  
```{r, eval=FALSE}
library(scales)
survey$new.vbl1 <- rescale(survey$var1) 
head(survey$new.vbl1)
```


#### Creating Sum Scores
```{r, eval=FALSE}
# Sum Score of specific rows 1-9
# na.rm = TRUE ---> ignores missing values in computations
data$sum <- rowSums(data[c(1:9)], na.rm=TRUE)

#or create a sum score using the specific variable names
rowSums(data[,c('vbl1', 'vbl2', 'vbl3')], na.rm=TRUE)

# if you wanted the column sums, could also do 'colSums'
```
<br>
<br>


***

<br>
<br>


# PLOTS!


### Quick Base R Plots:

**Basic plots - histogram, scatter.hist, normal plot....**
```{r, eval=FALSE}
hist(x) #histogram
scatter.hist(x, y, smooth = T, ab=TRUE)
plot(x, main="", xlab="", ylab="", legend=TRUE) #basic plot with title and x/y labels & legend
```

**boxplot**
```{r, eval=FALSE}
boxplot(iris$Sepal.Length, col="blue")#boxplot w/ 1 varialbe
boxplot(variable2 ~ variable1, data=data) #boxplot w/ 2 variables
```

**interaction plot**
```{r, eval=FALSE}
#interaction plot - interaction of varialbe of interest x age by gender
interaction.plot(main.data$age,main.data$gender,main.data$othervbl,
                 xlab="Age",ylab="vblname",trace.label = "Gender")
```


**Stacking multiple plots within same window**
```{r, eval=FALSE}
# for stacking plots - change the second number for how many technical plots you have
par(mfrow=c(1,2)) # num of rows and num of columns
hist(x, y, xlab="x axis title", ylab="y axis title", main="graph title")
hist(x, y, xlab="x axis title", ylab="y axis title", main="graph title2")

```
<br>
<br>

### Plots Using ggplot2:

```{r, eval=FALSE}
library(ggplot2)
# Basic histogram with two groups --- fill=group variable
ggplot(df, aes(x=weight, fill=group)) +
  geom_histogram(fill="white", color="black")+
  geom_vline(aes(xintercept=mean(weight)), color="blue",
             linetype="dashed")+
  labs(title="Weight histogram plot",x="Weight(kg)", y = "Count")+
  theme_classic()
```
[Good in-depth GGplot tutorial](https://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html)

<br>
<br>


***


# Tables & Output

### Create a quick table manually
```{r, eval=FALSE}
outTab<- round(cbind(cf3.2, se3.2, t3.2, p3.2, fmi3.2), 3) # 3=is how many digits to round 
colnames(outTab) <- c("Estimate", "SE", "t-Stat", "p-Value", "FMI") #these correspond to the values above
rownames(outTab) <- c("rowname1", "rowname2", "rowname3", "rowname4")
outTab

## Write out nice table to wd:
write.csv(outTab, paste0(output.name, "resTable.csv"), row.names = TRUE)
```
<br>
<br>



### APA Tables

APA Tables is chill for some things...others not so much. 

**Print a correlation table to word using APA Tables**
```{r, eval=FALSE}
library(apaTables)
apa.cor.table(data, filename = "CorTable.doc", table.number = NA,
              show.conf.interval = F, landscape = TRUE)
```
<br>


***


# Helpful Tricks (but no treats, sigh)

<br>
#### Functions that are useful for random things:
```{r, eval=FALSE}
noquote()
paste()
paste0()
lapply()
apply()
do.call()
rep()
rnorm()
list()
unlist()
```
<br>
<br>
<br>


**Add a fun sound at the end of your code so you know your model is done!**
```{r, eval=FALSE}
library(beepr)
beep(sound = 1) ## has 1-10 diff sounds to chose from - #8 is mario :)
```


**Finding column number of a particular variable**
```{r, eval=FALSE}
which(colnames(df)=="vbl.name" )
```
<br>

**Checking if Matrix is Positive Definite! (comes in handy for SEM models)**
```{r, eval=FALSE}
library(matrixcalc)
is.singular.matrix(matrix.name) #If matrix is singlar/non-invertible, it returns TRUE.
```



