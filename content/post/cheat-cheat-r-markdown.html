---
title: "Helpful R Cheat Sheet"
author: "Allie Choate"
date: "06/01/2019"
slug: r-code
categories: []
tags: []
description: ~
---



<div id="the-basics" class="section level1">
<h1>The Basics</h1>
<div id="reading-in-outputting-data" class="section level2">
<h2>Reading In &amp; Outputting Data:</h2>
<p><strong>Read in a delimited text file</strong></p>
<pre class="r"><code>df &lt;- read.table(‘file.txt’) 
#if you have missing codes, can do:
df &lt;- read.table(‘file.txt’, missing = -99)
#if you have multiple missing codes, can do:
df &lt;- read.table(‘file.txt’, na.strings=c(&quot;-98&quot;,&quot;-99&quot;, &quot;-999&quot;)) </code></pre>
<p><strong>Similarly, read in a csv file</strong></p>
<pre class="r"><code>df &lt;- read.csv(‘file.csv’)</code></pre>
<p><br></p>
<p><strong>Read out a delimited text file</strong></p>
<pre class="r"><code>write.table(df, ‘file.txt’) #saves this to your working directory </code></pre>
<p><strong>Read out a csv file</strong></p>
<pre class="r"><code>write.csv(df, ‘file.csv’)</code></pre>
<p><br>
<br></p>
<div id="write-an-r-based-datset-to-a-spss-file-using-foreign" class="section level4">
<h4>Write an R-based datset to a SPSS file using ‘foreign’</h4>
<pre class="r"><code>library(foreign)
write.foreign(data.frame, &quot;mydata.txt&quot;, 
              &quot;mydata1.sps&quot;, #name you want your SPSS file to be called
              package=&quot;SPSS&quot;)</code></pre>
<p><br>
<br>
<br></p>
</div>
</div>
<div id="checking-data-structure" class="section level2">
<h2>Checking Data Structure</h2>
<div id="checking-structuredimensions-of-a-df" class="section level3">
<h3>Checking Structure/Dimensions of a DF</h3>
<p><strong>Check structure/dimension of a variable of df</strong></p>
<pre class="r"><code>str(dat) #check structure of data
dim(dat) #check the number of dimensions of data
class(dat$vbl) #check what type of class a vbl is</code></pre>
<p><strong>Print First or Last 10 Rows of the Data</strong></p>
<pre class="r"><code>head(mydata, n=10) #first
tail(mydata, n=10) #last</code></pre>
<p><br>
<br></p>
</div>
<div id="quick-sorting-of-data" class="section level3">
<h3>Quick Sorting of Data</h3>
<pre class="r"><code>#Sort dataset by ID
df[order(df$ID),]

#Sort dataset by Item1 and Item2 
df[order(df$Item1,df$Item2),]

#Sort dataset by Item1 (ascending) and Item2 (descending)
df[order(df$Item1, -df$Item2),]</code></pre>
<p><br>
<br></p>
</div>
</div>
<div id="other-helpful-data-commands" class="section level2">
<h2>Other Helpful Data Commands</h2>
<div id="re-naming-variables-in-a-df" class="section level3">
<h3>Re-naming Variables in a df</h3>
<p><strong>View Names in df</strong></p>
<pre class="r"><code>names(df) 
#or
dput(names(df))</code></pre>
<p><strong>Re-name all names in dataset, generally speaking</strong></p>
<pre class="r"><code>names(df)&lt;- c(&quot;whatever1&quot;, &quot;whatever2&quot;,&quot;whatever3&quot;)</code></pre>
<p><strong>Re-name only Row Names:</strong></p>
<pre class="r"><code># For Row Names
rownames(df)&lt;- c(&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;)
#or more simply
rownames(df)&lt;- paste0(&quot;V&quot;, 1:3)</code></pre>
<p><strong>Re-Name only Columns</strong></p>
<pre class="r"><code>colnames(df)&lt;- c(&quot;var1&quot;,&quot;var2&quot;,&quot;var3&quot;)</code></pre>
<p><br>
<br></p>
<div id="changing-the-class-of-variables-in-r" class="section level4">
<h4>Changing The Class of Variables in R</h4>
<p><strong>Setting a Variable as Ordinal/Numeric/Categorical</strong></p>
<pre class="r"><code>as.ordered(df$x) #x = some variable 
as.numeric(df$x)
as.factor(df$x)</code></pre>
<p><strong>Change the level names of a categorical variable</strong></p>
<pre class="r"><code>data$vbl.name&lt;- factor(data$vbl.name, levels = c(0,1), labels = c(&quot;Male&quot;,&quot;Female&quot;))</code></pre>
<p><strong>Change ALL variables to be all numeric:</strong></p>
<pre class="r"><code>new.df &lt;- data.frame(lapply(old.df, function(x) as.numeric(as.character(x))))</code></pre>
<p><br>
<br></p>
<hr />
<p><br>
<br></p>
</div>
</div>
</div>
</div>
<div id="missing-data-checks" class="section level1">
<h1>Missing Data Checks</h1>
<div id="view-delete-missingness---this-does-listwise-deletion" class="section level3">
<h3>View &amp; Delete Missingness - (this does listwise deletion)**</h3>
<pre class="r"><code>sum(is.na(df)) #easy way to see how many &#39;NAs&#39; are in dataset
sum(is.na(df$x)) #or similarly, check for a particular variable

# Omit any missing data entries
clean.df&lt;-na.omit(df)</code></pre>
<p><strong>Function to change missing values to ‘NA’ (useful for if you forgot to tell R what your missing values were when you read in your data)</strong></p>
<pre class="r"><code>fix_missing &lt;- function(x) {
  x[x == -99] &lt;- NA
  x
}
df[] &lt;- lapply(df, fix_missing)</code></pre>
<p><br>
<br></p>
</div>
<div id="using-the-mice-package-for-missing-data-checks" class="section level3">
<h3>Using the mice package for Missing Data Checks:</h3>
<pre class="r"><code>library(mice) #load the mice package 

## look at the percent of missingness in data:
pm &lt;- colMeans(is.na(missData))
pm

## Compute the covaraince coverage using the md.pairs() is part of the mice package
cover &lt;- md.pairs(missData)$rr / nrow(missData)
cover
#visuals 
hist(cover)
range(cover)


## Compute the unique response patterns:
unique.rep &lt;- md.pattern(missData)
unique.rep</code></pre>
<p><br>
<br></p>
<hr />
<p><br>
<br></p>
</div>
</div>
<div id="basic-descriptives" class="section level1">
<h1>Basic Descriptives</h1>
<p><br></p>
<div id="base-r---descriptivefrequency-commands" class="section level3">
<h3>Base R - Descriptive/Frequency Commands</h3>
<pre class="r"><code># x = some variable

sd(df$x)                  # Calculate standard deviation
summary(df$x)            # Returns a summary of x: mean, min, max etc.
t.test(df$x)              # Student&#39;s t-test
var(df$x)                 # Calculate variance
density(df$x)            # Compute kernel density estimates
table(df$Gender)        # counts for gender categories
table(df$`Marital Status`, data$Gender) # cross classication counts for &#39;gender&#39; by &#39;marital status&#39;</code></pre>
</div>
<div id="other-descriptive-option-using-rmisc" class="section level3">
<h3>Other Descriptive Option (using Rmisc)</h3>
<pre class="r"><code>library(Rmisc)
Descriptives&lt;-summarySE(df, measurevar=&quot;vblofinterest&quot;, groupvars=c(&quot;gender&quot;,&quot;age&quot;))</code></pre>
</div>
<div id="descriptives-option-2-using-psych" class="section level3">
<h3>Descriptives Option #2 (using Psych)</h3>
<pre class="r"><code>library(psych)
describeBy(df$vbl, group = df$groupvar)
describe(df$vbl) # no group</code></pre>
<p><br>
<br></p>
<hr />
<p><br>
<br></p>
</div>
</div>
<div id="subsetting-data-in-r" class="section level1">
<h1>Subsetting Data in R:</h1>
<div id="typical-ways-to-subset-data" class="section level3">
<h3>Typical Ways to Subset Data:</h3>
<p>1.) my_df[1:3] (no comma) will subset my_df, returning the first three columns as a data frame.</p>
<p>2.) my_df[1:3, ] (with comma, numbers to left of the comma) will subset my_df and return the first three rows as a data frame.</p>
<p>3.) my_df[, 1:3] (with comma, numbers to right of the comma) will subset my_df and return the first three columns as a data frame, the same as my_df[1:3].</p>
<p><br></p>
</div>
<div id="easy-example-to-physically-see-how-subsetting-works-in-r" class="section level3">
<h3>Easy Example to Physically See How Subsetting Works in R:</h3>
<p><strong>For subsetting rows:</strong></p>
<pre class="r"><code># creating a fake df
df &lt;- data.frame(x = 1:4, y = 4:1, z = letters[1:4]) 

# Subsetting by row &#39;3&#39;
df[df$x == 3, ]
##   x y z
## 3 3 2 c

# Calling Row 1 &amp; 3
df[c(1, 3), ]
##   x y z
## 1 1 4 a
## 3 3 2 c</code></pre>
<p><strong>For subsetting columns:</strong></p>
<pre class="r"><code># There are two ways to select columns from a data frame: 

  # 1. Like a list
new.df &lt;- df[c(&quot;x&quot;, &quot;z&quot;)] #based on vbl names
new.df &lt;- df[c(1:3)] # based on vbl columns numbers, bracket indicates we&#39;re subsetting column 1 through 3.
  
  # 2. Like a matrix
new.df &lt;-df[, c(&quot;x&quot;, &quot;z&quot;)]
new.df &lt;-df[, c(1:3)]


# There&#39;s an important difference if you select a SINGLE column...
# ...matrix subsetting simplifies by default, list subsetting does not.

str(df[&quot;x&quot;])
## &#39;data.frame&#39;:    4 obs. of  1 variable:
##  $ x: int  1 2 3 4
#  VS
str(df[, &quot;x&quot;])
##  int [1:4] 1 2 3 4</code></pre>
<p><strong>Quick Subsetting of Rows &amp; Columns Together:</strong></p>
<pre class="r"><code># create random distribution. For example, draw 5 random samples of size 10 from a N(10,1):
fake.dat&lt;-matrix(rnorm(n=100,mean=10,sd=1),ncol=10, nrow=20)
#subset 1-8 rows and columns 1:2
new.df&lt;-fake.dat[1:6, 1:4]
print(new.df)</code></pre>
<pre><code>##           [,1]      [,2]      [,3]      [,4]
## [1,] 10.334175  9.530656  8.963259  8.692611
## [2,]  8.459072 10.568779  9.591110 10.071149
## [3,] 10.955469  9.621190 10.707286 12.183149
## [4,]  9.417699  8.763645  8.987695 10.415385
## [5,] 11.076360  9.458798  9.735055 10.889185
## [6,] 10.482250 10.240480 10.172596 10.166228</code></pre>
<ul>
<li><p>Can see that we successfully selected rows 1-6 and columns 1-4.</p></li>
<li><p>If you wanted to select columns or rows that were not right next to each other, can do this:</p></li>
</ul>
<pre class="r"><code>fake.dat[c(1,4,9), c(1,7,8)] #this selects rows 1,4, &amp; 9 and columns 1, 7, &amp; 8.</code></pre>
<pre><code>##           [,1]     [,2]     [,3]
## [1,] 10.334175 9.530656 8.963259
## [2,]  9.417699 8.763645 8.987695
## [3,]  9.981583 9.484468 9.855846</code></pre>
<p><br>
<br></p>
<div id="delete-a-column-from-a-df" class="section level4">
<h4>Delete a Column From a df</h4>
<p><strong>3 ways to delete a column quickly:</strong></p>
<pre class="r"><code>new.data&lt;- df[colnames(df)!=&quot;vblname.to.exclude&quot;]

# Can also do this:
df$vbl.to.exclude&lt;- NULL

#OR if you know column(s) you want to remove, can do this:
new.data&lt;- df[-c(2:4)] #this removes columns 2:4</code></pre>
<p><br>
<br></p>
</div>
</div>
<div id="subsetting-based-on-specific-components-of-the-df" class="section level3">
<h3>Subsetting Based on Specific Components of the df:</h3>
<p>** Subsetting based on a level of a factor - will subset all of the data and include only that specific ‘level’ of a categorical variable.**</p>
<pre class="r"><code>new.data&lt;- subset(df, level===1) #level = whatever the level of your factor is called that you&#39;re interested in.</code></pre>
<p><strong>Subsetting based on specific values of a variable</strong></p>
<pre class="r"><code>#Select cases only where Vbl1&gt;= 20 and Vbl2 &gt;10 + select a few other variables for a new dataset.
newdata &lt;- subset(df, df$Vbl1&gt;= 20 &amp; df$Vbl2 &gt;10, 
                  select=c(Vbl1, Vbl2, gender, ID)) # These are all the other variables you want to include in the new df</code></pre>
<p><strong>Another example for subsetting based on specific values of a variable</strong></p>
<pre class="r"><code>#Select only cases where gender is 0 (male), and &#39;depression&#39; is greater then 10. Also select all variables from &#39;Anxiety&#39; to &#39;PTSD&#39;
newdata2 &lt;- subset(df, df$gender==&quot;0&quot; &amp; df$depression&gt;10, select=c(Anxiety:PTSD))</code></pre>
<p><strong>Subsetting THIS condition OR that condition</strong></p>
<pre class="r"><code>#If we wanted all rows where either d == &quot;A&quot; or a &gt; 0.5, use the OR operator (|):
my_df[which(my_df$d == &quot;A&quot; | my_df$a &gt; 0.5),]</code></pre>
<p><br>
<br></p>
</div>
<div id="alternative-methods-for-quick-subsetting---use-dplyr" class="section level3">
<h3>Alternative Methods for Quick Subsetting - Use ‘dplyr’</h3>
<p><strong>dplyr is nice if you want to subset from your original dataset based on a set of variables that are similarly named. For example: </strong></p>
<pre class="r"><code>library(dplyr)
# Variable starts with...
df_pract&lt;-select(data, starts_with(&quot;var&quot;)) #example would be &quot;var1&quot;,&quot;var2&quot;,&quot;var3&quot;, etc.
# Variable ends with...
df_pract&lt;-select(data, ends_with(&quot;14&quot;))</code></pre>
<p><br>
<br></p>
<hr />
<p><br>
<br></p>
</div>
</div>
<div id="recoding-re-scaling-variables" class="section level1">
<h1>Recoding &amp; Re-Scaling Variables:</h1>
<div id="quick-way-to-manually-re-code-all-variables-in-a-df" class="section level4">
<h4>Quick Way to Manually Re-Code ALL Variables in a df</h4>
<p><strong>To demonstrate, making fake data</strong></p>
<ul>
<li>‘Survey’ function for ‘var1’ –&gt;draws 20 samples from integers 1:5 w/ replacement</li>
</ul>
<pre class="r"><code>library(car)</code></pre>
<pre><code>## Warning: package &#39;car&#39; was built under R version 3.4.4</code></pre>
<pre><code>## Loading required package: carData</code></pre>
<pre><code>## Warning: package &#39;carData&#39; was built under R version 3.4.4</code></pre>
<pre class="r"><code>survey &lt;- data.frame(&quot;var1&quot; = sample(x = 1:5, size = 20, replace = TRUE),
                     &quot;var2&quot; = rep(1:5, each=4),
                     &quot;age&quot; =  sample(x = 10:45, size = 20, replace = TRUE))</code></pre>
<p><strong>Now, let’s just change var1 to have different values (currently has values 1-5)</strong></p>
<ul>
<li>Brackets allow subsetting of columns…could also do ‘survey$var1’</li>
<li>This will change all ‘5’ in column 1 (var1) to be 6, and all ‘1s’ to be ‘1.5.’</li>
</ul>
<pre class="r"><code>survey$var1&lt;- lapply(survey[[1]], function(x) {x&lt;- recode(x, &quot;5=6;1=1.5&quot;); x})</code></pre>
<p><strong>If we wanted to rescale all values in all columns of the entire survey dataset, we could do so like this:</strong></p>
<pre class="r"><code>recode.cols&lt;- apply(survey, 2, function(x) {x&lt;- recode(x, &quot;5=6;1=1.5&quot;); x})
head(recode.cols)</code></pre>
<pre><code>##      var1 var2 age
## [1,]    2  1.5  45
## [2,]    3  1.5  15
## [3,]    3  1.5  24
## [4,]    3  1.5  23
## [5,]    3  2.0  36
## [6,]    3  2.0  40</code></pre>
<pre class="r"><code># to re-scale all row values, just change the &#39;2&#39; to a &#39;1&#39;
recode.rows&lt;- apply(survey, 1, function(x) {x&lt;- recode(x, &quot;5=6;1=1.5&quot;); x})
head(recode.rows)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
## [1,]  2.0  3.0  3.0  3.0    3    3    6    4    3     2   1.5     2     6
## [2,]  1.5  1.5  1.5  1.5    2    2    2    2    3     3   3.0     3     4
## [3,] 45.0 15.0 24.0 23.0   36   40   13   42   18    45  45.0    23    23
##      [,14] [,15] [,16] [,17] [,18] [,19] [,20]
## [1,]     3     2     4     6     6     3     6
## [2,]     4     4     4     6     6     6     6
## [3,]    20    36    33    41    20    21    26</code></pre>
</div>
<div id="rescaling-a-variable-to-be-between-0-1-with-the-scales-package" class="section level4">
<h4>Rescaling a Variable to be between 0-1 with the scales package:</h4>
<ul>
<li>Use same ‘survey’ dataset from above:</li>
</ul>
<pre class="r"><code>library(scales)
survey$new.vbl1 &lt;- rescale(survey$var1) 
head(survey$new.vbl1)</code></pre>
</div>
<div id="creating-sum-scores" class="section level4">
<h4>Creating Sum Scores</h4>
<pre class="r"><code># Sum Score of specific rows 1-9
# na.rm = TRUE ---&gt; ignores missing values in computations
data$sum &lt;- rowSums(data[c(1:9)], na.rm=TRUE)

#or create a sum score using the specific variable names
rowSums(data[,c(&#39;vbl1&#39;, &#39;vbl2&#39;, &#39;vbl3&#39;)], na.rm=TRUE)

# if you wanted the column sums, could also do &#39;colSums&#39;</code></pre>
<p><br>
<br></p>
<hr />
<p><br>
<br></p>
</div>
</div>
<div id="plots" class="section level1">
<h1>PLOTS!</h1>
<div id="quick-base-r-plots" class="section level3">
<h3>Quick Base R Plots:</h3>
<p><strong>Basic plots - histogram, scatter.hist, normal plot….</strong></p>
<pre class="r"><code>hist(x) #histogram
scatter.hist(x, y, smooth = T, ab=TRUE)
plot(x, main=&quot;&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, legend=TRUE) #basic plot with title and x/y labels &amp; legend</code></pre>
<p><strong>boxplot</strong></p>
<pre class="r"><code>boxplot(iris$Sepal.Length, col=&quot;blue&quot;)#boxplot w/ 1 varialbe
boxplot(variable2 ~ variable1, data=data) #boxplot w/ 2 variables</code></pre>
<p><strong>interaction plot</strong></p>
<pre class="r"><code>#interaction plot - interaction of varialbe of interest x age by gender
interaction.plot(main.data$age,main.data$gender,main.data$othervbl,
                 xlab=&quot;Age&quot;,ylab=&quot;vblname&quot;,trace.label = &quot;Gender&quot;)</code></pre>
<p><strong>Stacking multiple plots within same window</strong></p>
<pre class="r"><code># for stacking plots - change the second number for how many technical plots you have
par(mfrow=c(1,2)) # num of rows and num of columns
hist(x, y, xlab=&quot;x axis title&quot;, ylab=&quot;y axis title&quot;, main=&quot;graph title&quot;)
hist(x, y, xlab=&quot;x axis title&quot;, ylab=&quot;y axis title&quot;, main=&quot;graph title2&quot;)</code></pre>
<p><br>
<br></p>
</div>
<div id="plots-using-ggplot2" class="section level3">
<h3>Plots Using ggplot2:</h3>
<pre class="r"><code>library(ggplot2)
# Basic histogram with two groups --- fill=group variable
ggplot(df, aes(x=weight, fill=group)) +
  geom_histogram(fill=&quot;white&quot;, color=&quot;black&quot;)+
  geom_vline(aes(xintercept=mean(weight)), color=&quot;blue&quot;,
             linetype=&quot;dashed&quot;)+
  labs(title=&quot;Weight histogram plot&quot;,x=&quot;Weight(kg)&quot;, y = &quot;Count&quot;)+
  theme_classic()</code></pre>
<p><a href="https://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html">Good in-depth GGplot tutorial</a></p>
<p><br>
<br></p>
<hr />
</div>
</div>
<div id="tables-output" class="section level1">
<h1>Tables &amp; Output</h1>
<div id="create-a-quick-table-manually" class="section level3">
<h3>Create a quick table manually</h3>
<pre class="r"><code>outTab&lt;- round(cbind(cf3.2, se3.2, t3.2, p3.2, fmi3.2), 3) # 3=is how many digits to round 
colnames(outTab) &lt;- c(&quot;Estimate&quot;, &quot;SE&quot;, &quot;t-Stat&quot;, &quot;p-Value&quot;, &quot;FMI&quot;) #these correspond to the values above
rownames(outTab) &lt;- c(&quot;rowname1&quot;, &quot;rowname2&quot;, &quot;rowname3&quot;, &quot;rowname4&quot;)
outTab

## Write out nice table to wd:
write.csv(outTab, paste0(output.name, &quot;resTable.csv&quot;), row.names = TRUE)</code></pre>
<p><br>
<br></p>
</div>
<div id="apa-tables" class="section level3">
<h3>APA Tables</h3>
<p>APA Tables is chill for some things…others not so much.</p>
<p><strong>Print a correlation table to word using APA Tables</strong></p>
<pre class="r"><code>library(apaTables)
apa.cor.table(data, filename = &quot;CorTable.doc&quot;, table.number = NA,
              show.conf.interval = F, landscape = TRUE)</code></pre>
<p><br></p>
<hr />
</div>
</div>
<div id="helpful-tricks-but-no-treats-sigh" class="section level1">
<h1>Helpful Tricks (but no treats, sigh)</h1>
<p><br>
#### Functions that are useful for random things:</p>
<pre class="r"><code>noquote()
paste()
paste0()
lapply()
apply()
do.call()
rep()
rnorm()
list()
unlist()</code></pre>
<p><br>
<br>
<br></p>
<p><strong>Add a fun sound at the end of your code so you know your model is done!</strong></p>
<pre class="r"><code>library(beepr)
beep(sound = 1) ## has 1-10 diff sounds to chose from - #8 is mario :)</code></pre>
<p><strong>Finding column number of a particular variable</strong></p>
<pre class="r"><code>which(colnames(df)==&quot;vbl.name&quot; )</code></pre>
<p><br></p>
<p><strong>Checking if Matrix is Positive Definite! (comes in handy for SEM models)</strong></p>
<pre class="r"><code>library(matrixcalc)
is.singular.matrix(matrix.name) #If matrix is singlar/non-invertible, it returns TRUE.</code></pre>
</div>
